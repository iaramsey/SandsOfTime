{SandsOfTime Top Level}

con
  _clkfreq = 300_000_000

  {Absolute Encoder Constants}
  CS0 = 1    ' Start of encoder chip select pin range
  CSf = 12    ' End of encoder chip select pin range
  NumEnc = CSf - CS0 + 1
  CLK = 0
  DATA = 13
  AbsEncTolerance = 3 ' In encoder counts

  {Quadrature Encoder Constants}
  ExtendEncBotPin = 34
  ExtendEncTopPin = 35

  ArmEncTopPin = 33
  ArmEncBotPin = 32

  QuadEncTolerance = 10

  {Limit Switch Constants}
  LSExtend = 38
  LSRetract = 37

  IndSensor = 36

  {Motor Constants}
  StallThreshold = 1400
  numClockPulses = 10
  numBasePeriods = 1000

  ExtensionSpeed = 1000

  {LED Constants}

  {LCD Constants}
  ' Pins
  #20, JoyUp, JoyDown, JoyLeft, JoyRight, JoyButton
  LCDRx = 25

var
  {
    Hour to index: ' TODO: THIS MIGHT CHANGE
    1 - 0
    .
    .
    .
    12 - 11
  }
  word EncCurPos[NumEnc]
  word EncSetPoint[NumEnc] ' All initialized to 0 at runtime
  long Stack2[100], Stack3[100], Stack4[100], Stack5[100]
  word time[7] ' hour, minute, second, day, date, month, year
  word hour, minute, second, day, date, month, year ' Does this mean that they are consecutive in memory?

  long arm_enc_count

  long max_extension_count
  long extend_enc_count

dat
' where arm needs to be to reach a certain hourglass (starting at index 0, hour 1)
hour_pos word 0, 710, 1380, 2081, 2704, 3330, 4053, 4750, 5335, 6120, 6825, 7546, 0

' how far arm needs to extend to reach in quadrature encoder counts
hour_extension long 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0


obj
  ' object parametrization requires spin v37
  DS3234 : "DS3234"       | SS=19, MOSI=18, MISO=17, SCLK=16, SQW=-1
  main_arm : "BTS7960"    | RPWM=31, LPWM=30, R_EN=29, L_EN=28, R_IS=27, L_IS=26, MinDuty=400 ' Currently enables are just to 5V
  arm_extend : "DRV8801"  | DIR=40, PWM=39, BRAKE=42, SLEEP=41, FAULT=-1, CS=-1, MinDuty=0 ' Currently CS not on the board
  arm_spin : "DRV8801"    | DIR=44, PWM=43, BRAKE=46, SLEEP=45, FAULT=-1, CS=-1, MinDuty=800
  pst : "pst_driver"
  lcd : "jm_serial" ' TODO: ask Garner if this is the best thing to use


pub TestAllRotations()
  cogspin(3, ReadMainArmEncoder(), @Stack3)
  repeat until homed == 1
  cogspin(4, ReadExtensionEncoder(), @Stack4)   ' Process reading quadrature encoder
  repeat until
  repeat i from 0 to 11
    SetMainArmPos(hour_pos[i])
    Extend()
    RotateHourglass(hour_i, abs (512 - EncCurPos[hour_i]) < AbsEncTolerance ? 0 : 512) ' Should swap between 0 and 512
    Retract()


pub Main() | hour_i, i, error
  cogspin(2, ReadAbsEncoders(), @Stack2)    ' Process reading absolute encoders

  main_arm.InitPins(numClockPulses, numBasePeriods) ' still needs to be initialized in the cog
  cogspin(3, ReadMainArmEncoder(), @Stack3)
  waitatn() ' wait for homing to finish

  arm_extend.InitPins(numClockPulses, numBasePeriods) ' still needs to be initialized in the cog
  cogspin(4, ReadExtensionEncoder(), @Stack4)   ' Process reading quadrature encoder
  waitatn() ' wait for extension calibration to finish

  cogspin(5, ReadRTClock(), @Stack5)       ' Process reading the clock and handling LCD time setting

  arm_spin.InitPins(numClockPulses, numBasePeriods)

  repeat
    'if pollatn() ' if this cog is strobed, wait until it's strobed again
    '  waitatn()
    ' if it's time to flip an hourglass (~20 seconds before multiple of 5 minutes)
    if (minute +// 5) == 4 && second +>= 40
      hour_i := minute/5 ' since this is not floating point divide, should round down (i.e. 4/5 = 0) so the indices should line up
      SetMainArmPos(hour_pos[hour_i]) ' Or round((hour_i+1)*.85.3)
      Extend(1000) ' Extend to mesh with gear ; Could start rotating first to ensure meshing
      ' TODO: Wait for arm to extend and then flip when it will be ~ flipped at 0
      RotateHourglass(hour_i, abs (512 - EncCurPos[hour_i]) < AbsEncTolerance ? 0 : 512) ' Should swap between 0 and 512
      Retract(1000)
    else ' otherwise use the arm to show the hour and maintain hourglass positions
      repeat i from 0 to NumEnc-1 ' all absolute encoders other than main_arm
        error := CalculateAbsError(EncCurPos[i], EncSetPoint[i]) ' Find the error between each hg setpoint and current position
        if abs error > AbsEncTolerance ' an hourglass is out of position
          SetMainArmPos(hour_pos[i]) ' Or round((hour_i+1)*.85.3)
          RotateHourglass(i, EncSetPoint[i])
          error := CalculateAbsError(EncCurPos[i], EncSetPoint[i])
      SetMainArmPos(hour_pos[hour]) ' Or round(hour_i*85.3)


{{Read all absolute encoder positions via SPI into the EncCurPos list}}
pub ReadAbsEncoders() | i, value
  dirhigh(CLK)
  pinh(CLK)
  dirlow(DATA)
  repeat i from CS0 to CSf
    dirhigh(i)
    pinh(i)
  ' dirh(CSF..CS0) ' TODO
  ' pinh(CSF..CS0)
  repeat
    repeat i from CS0 to CSf
      pinl(i) ' Chip Select
      waitus(1) ' Propeller 2 fast 2 furious
      pinl(CLK)
      waitus(1)
      value:=0
      repeat 16   ' Read 16 bits (top 10 are position)
        pinh(CLK)
        waitus(1)
        value := (value << 1) | pinr(DATA)
        pinl(CLK)
        waitus(1)
      EncCurPos[i-CS0] := value >> 6
      pinh(CLK)
      waitus(1)
      pinh(i)
      waitus(1)


{{Home the main arm and then constantly read the encoder}}
pub ReadMainArmEncoder()
  ' Start the quadrature encoder
  dirlow(IndSensor) ' Inverted logic
  main_arm.InitPins(numClockPulses, numBasePeriods)
  ' Home main arm
  if pinr(IndSensor) <> 0
    ' Drive until it hits the induction sensor
    main_arm.DriveForward(700)
    repeat until pinr(IndSensor) == 0
    main_arm.Stop()
  pinstart(ArmEncBotPin, p_quadrature + %0000<<28 + %0001<<24, 0, 0)
  ' could find max counts

  cogatn(0)
  repeat
    if pinr(IndSensor) == 0
      arm_enc_count:=0
      dirl(ArmEncBotPin) ' Should reset the count on the pin
      dirh(ArmEncBotPin)
    arm_enc_count := rdpin(ArmEncBotPin)
    waitms(50)

{{Rotates the main arm to absolute encoder position given by enc_pos}}
pub SetMainArmPos(enc_pos) | error ' TODO: optimize to understand it is a circle
  error := enc_pos - arm_enc_count
  repeat while abs error > QuadEncTolerance
    main_arm.Drive(error*numBasePeriods/8192)
    error := enc_pos - arm_enc_count
  main_arm.Stop()

{{Read clock and handle LCD}}
pub ReadRTClock() | addr
  DS3234.InitPins()

  ' set joystick pins as inputs
  dirlow(JoyUp) ' Could do JoyUp..JoyButton, but if they aren't sequential that gets messy
  dirlow(JoyDown)
  dirlow(JoyLeft)
  dirlow(JoyRight)
  dirlow(JoyButton)

  repeat
    ' Read the time from the chip
    DS3234.GetTime()
    ' Convert it to usable numbers for our purposes and return
    second, minute, hour, day, date, month, year := DS3234.ConvertToReadable() ' Idk if this works

    ' When the button on the joystick is pressed, editing begins
    if pinr(JoyButton) <> 0
      ' TODO: may need to start and stop main cog?
      lcd.startx(LCDRx, LCDRx, 9600)
      ' Debounce button
      waitms(100)
      ' Now entered editing mode and will exit once button is pressed again
      addr := @hour
      repeat until pinr(JoyButton) <> 0
        cogatn(0) ' strobe main to stop while editing is happening
        ' Case statement?

        ' Transition between fields (hour, minute, second)
        if pinr(JoyRight)
          addr := addr + 16 ' Increment address by 16 because they are words
        elseif pinr(JoyLeft)
          addr := addr - 16 ' Decrement address
        elseif pinr(JoyUp)
          word[addr] := word[addr] + 1 ' Increment value
        elseif pinr(JoyDown)
          word[addr] := word[addr] - 1 ' Decrement value

        ' TODO: I hate this so much
        ' Limit either end
        'hour := 1 #> hour <# 12
        if hour > 12
          hour := 1
        elseif hour < 1
          hour := 12
        ' minute := 0 #> minute <# 59
        if minute > 59
          minute := 0
        elseif minute < 0
          minute := 59
        'second := 0 #> second <# 59
        if second > 59
          second := 0
        elseif second < 0
          second := 59
        ' day := 0 #> day <# 6
        if day > 6
          day := 0
        elseif day < 0
          day := 6
        ' date := 1 #> date <# 31
        if date > 31
          date := 1
        elseif date < 1
          date := 31
        ' month := 1 #> month <# 12
        if month > 12
          month := 1
        elseif month < 1
          month := 12

        ' Update LCD display
        ' TODO: may need to set position on lcd
        lcd.dec(hour)
        lcd.str(string(":"))
        if minute < 10
          lcd.dec(0)
        lcd.dec(minute)
        lcd.str(string(":"))
        if second < 10
          lcd.dec(0)
        lcd.dec(second)
        lcd.str(string("    "))
        case day
          0:lcd.str(string("Sunday"))
          1:lcd.str(string("Monday"))
          2:lcd.str(string("Tuesday"))
          3:lcd.str(string("Wednesday"))
          4:lcd.str(string("Thursday"))
          5:lcd.str(string("Friday"))
          6:lcd.str(string("Saturday"))
      DS3234.SetTime(second, minute, hour, day, date, month, year) ' TODO: Incorporate the rest of the fields
      cogatn(0) ' strobe cog 0 to start back up

{{Extends arm until it hits the limit switch}}
pub Extend()
  ' If the limit switch is already pressed, do nothing
  if pinr(LSExtend) <> 1
    ' Else drive the arm forward until LSExtend reads 1 or stall is detected
    arm_extend.DriveForward(ExtensionSpeed)
    repeat until pinr(LSExtend) == 1
  ' Stop
  arm_extend.Stop()


{{Retracts arm until it hits the limit switch}}
pub Retract()
  ' If the limit switch is already pressed, do nothing
  if pinr(LSRetract) <> 1
    ' Else drive the arm backward until LSRetract reads 1
    arm_extend.DriveBackward(ExtensionSpeed)
    repeat until pinr(LSRetract) == 1
  ' Stop
  arm_extend.Stop()


{{Set up limit switches as inputs and determine maximum encoder counts then constantly updates the quadrature encoder count}}
pub ReadExtensionEncoder()
  dirlow(LSExtend)
  dirlow(LSRetract)
  arm_extend.InitPins(numClockPulses, numBasePeriods) ' Need to do this in the cog
  ' Drive Backward and hit limit switch --> 0 position
  Retract()

  'Start quadrature encoder smartpin reader watching provided Pin (Apin=%0000) and +1 pin up, (so Bpin=%0001)
  pinstart(ExtendEncBotPin, p_quadrature + %0000<<28 + %0001<<24, 0, 0)

  ' Drive Forward and hit 2nd limit switch --> Max position
  Extend()
  max_extension_count := rdpin(ExtendEncBotPin)

  ' Return to 0
  Retract()
  cogatn(0) 'let main cog know to start up
  repeat
    ' TODO: zero on limit switch
    extend_enc_count := rdpin(ExtendEncBotPin)
    waitms(50)


{{Calculates and returns the direction (positive or negative) and distance from the current absolute encoder count to the target}}
pub CalculateAbsError(current, target) : error
  error := target - current
  ' Theoretically handles wraparound
  if abs error > 512
    if error < 0
      error:=error+1024
    else
      error:=error-1024


{{Extends the arm to a quadrature encoder count given by enc_pos}}
pub ExtendArm(enc_pos) | error
  error := enc_pos - extend_enc_count
  repeat while abs error > QuadEncTolerance
    arm_extend.Drive(error*numBasePeriods/max_extension_count) ' TODO: Find good Kp
    error := enc_pos - extend_enc_count
  arm_extend.Stop()


{{Rotate the hourglass indicated by hr_i (0-11 where 0=1 and 11=12) to an absolute encoder position given by enc_pos}}
pub RotateHourglass(hr_i, enc_pos) | error
  EncSetPoint[hr_i] := enc_pos
  error := CalculateAbsError(EncCurPos[hr_i], enc_pos)
  repeat while abs error > AbsEncTolerance
    arm_spin.Drive(error*numBasePeriods/1024)
    error := CalculateAbsError(EncCurPos[hr_i], enc_pos)
  arm_spin.Stop()

{Pin Helper Methods}
pri dirhigh(pin)
  if pin > 31
    dirb.[pin-32]~~
  else
    dira.[pin]~~

pri dirlow(pin)
  if pin > 31
    dirb.[pin-32]~
  else
    dira.[pin]~