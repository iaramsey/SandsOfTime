{Clock Manual Control}


CON
  _clkfreq = 300_000_000                                                  'Standard clock frequency = 160 MHz

  {Absolute Encoder Constants}
  CS0 = 1    ' Start of encoder chip select pin range
  CSf = 12    ' End of encoder chip select pin range
  NumEnc = CSf - CS0 + 1
  CLK = 0
  DATA = 13
  AbsEncTolerance = 3 ' In encoder counts
  IndSensor = 36
  ArmEncTopPin = 33
  ArmEncBotPin = 32
  QuadEncTolerance = 5
  {Quadrature Encoder Constants}
  ExtendEncBotPin = 34
  ExtendEncTopPin = 35

  {Limit Switch Constants}
  LSExtend = 37
  LSRetract = 38

  numClockPulses = 10
  numBasePeriods = 1000

  ExtensionSpeed = 1000

  MainArmSpeed = 350



VAR
  long Stack2[100], Stack3[100], Stack4[100]
  long max_extend_pos
  long extend_pos
  byte extend_calibrated
  word EncCurPos[NumEnc+1]
  word EncSetPoint[NumEnc+1]
  byte homed, retracting
  long mainarm_pos
  long key

OBJ
  arm_extend : "DRV8801"  | DIR=40, PWM=39, BRAKE=42, SLEEP=41, FAULT=-1, CS=-1, MinDuty=0 ' Currently CS not on the board
  arm_spin : "DRV8801"    | DIR=44, PWM=43, BRAKE=46, SLEEP=45, FAULT=-1, CS=-1, MinDuty=800
  main_arm : "BTS7960"    | RPWM=31, LPWM=30, R_EN=29, L_EN=28, R_IS=27, L_IS=26, MinDuty=MainArmSpeed ' Currently enables are just to 5V

dat
' where arm needs to be to reach a certain hourglass (starting at index 0, hour 1)
hour_pos word 0, 710, 1380, 2081, 2704, 3330, 4053, 4750, 5335, 6120, 6825, 7546, 0

' how far arm needs to extend to reach in quadrature encoder counts
hour_extension long 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

{Pin Helper Methods}
pri dirhigh(pin) ' TODO: Make these do pin ranges
  if pin > 31
    dirb.[pin-32]~~
  else
    dira.[pin]~~

pri dirlow(pin)
  if pin > 31
    dirb.[pin-32]~
  else
    dira.[pin]~


{{Retracts arm until it hits the limit switch}}
PUB Main()
  'cogspin(2, ReadAbsEncoders(), @Stack2)
  pinstart(ExtendEncBotPin, p_quadrature + %0000<<28 + %0001<<24, 0, 0)
  main_arm.InitPins(numClockPulses, numBasePeriods)
  arm_spin.InitPins(numClockPulses, numBasePeriods)
  arm_extend.InitPins(numClockPulses, numBasePeriods)
  Retract()
  homed:=0
  cogspin(3, ReadMainArmEncoder(), @Stack3)
  repeat until homed == 1
  waitms(500)
  SetMainArmPos(0)
  'screen showing Main Arm and Extension Encoder positions
  cogspin(2, displaycounts(), @Stack2)
  debug(`term controls pos 100 540 color cyan size 50 1 textsize 20)
  'click in screen to control with keys
  repeat
    debug(`controls `PC_KEY(@key))
    if key == 1 'Left arrow = CCW
      main_arm.DriveForward(MainArmSpeed)
    elseif key == 2 ' Right arrow = CW
      main_arm.DriveBackward(MainArmSpeed)
    elseif key == 3 ' Up arrow = Extend
      arm_extend.DriveForward(1000)
    elseif key == 4 ' Down arrow = Retract
      'arm_extend.DriveBackward(1000)
      Retract()
    ' TODO: Page up and page down extend retract
    elseif key == 13
      arm_spin.DriveForward(1000)
    else
      main_arm.Stop()
      arm_extend.Stop()
      arm_spin.Stop()
    waitms(20)

pub displaycounts()
  repeat
    debug(sdec_long(rdpin(ArmEncBotPin)))
    debug(sdec_long(rdpin(ExtendEncBotPin)))
    waitms(100)

{{Extends the arm to a quadrature encoder count given by enc_pos}}
pub ExtendArm(enc_pos) | error
  error := enc_pos - rdpin(ExtendEncBotPin)
  repeat while abs error > QuadEncTolerance
    if error < 0
      arm_extend.Drive(-1000) ' TODO: Find good Kp
    else
      arm_extend.Drive(1000)
    error := enc_pos - rdpin(ExtendEncBotPin)
  arm_extend.Stop()


pub Retract()
  ' Drive the arm backward until LSRetract reads 1
  arm_extend.DriveBackward(1000)
  'retracting:=1
  waitms(500)
  repeat until pinr(LSRetract) == 1
  arm_extend.Stop()
  dirlow(ExtendEncBotPin) ' Should reset the count on the pin
  dirhigh(ExtendEncBotPin)


pub Extend()
  ' Drive the arm forward until LSExtend reads 1
  arm_extend.DriveForward(1000)
  waitms(500)
  repeat until pinr(LSExtend) == 1
  arm_extend.Stop()


pub DebugLS() | i, j
  debug(`term testTerm pos 100 440 color cyan size 50 1 textsize 20)
  repeat
    i := pinr(LSRetract)
    j := pinr(LSExtend)
    debug(`testTerm 1 'LSRetract = ', '`(i)', '   LSExtend = ', '`(j)')
    waitms(100)

{{Home the main arm and then constantly read the encoder}}
pub ReadMainArmEncoder()
  dirlow(IndSensor) ' Inverted logic
  main_arm.InitPins(numClockPulses, numBasePeriods)
  ' Home main arm
  if pinr(IndSensor) <> 0
    ' Drive until it hits the induction sensor
    main_arm.DriveBackward(800)
    repeat until pinr(IndSensor) == 0
    main_arm.Stop()
  ' Start the quadrature encoder
  pinstart(ArmEncBotPin, p_quadrature + %0000<<28 + %0001<<24, 0, 0)
  homed:=1
  ' could find max counts
  repeat
    if pinr(IndSensor)==0
      dirlow(ArmEncBotPin) ' Should reset the count on the pin
      mainarm_pos:=0
      dirhigh(ArmEncBotPin)
    mainarm_pos := rdpin(ArmEncBotPin)
    'debug(`mainArm '`(mainarm_pos)' 10)

{{Rotates the main arm to absolute encoder position given by enc_pos}}
pub SetMainArmPos(enc_pos) | error, Kp, delta_t ' TODO: optimize to understand it is a circle
  Kp := 2
  delta_t := 5 'ms
  error := mainarm_pos - enc_pos
  repeat while abs error > QuadEncTolerance
    if error > 0
      Kp := 10
    else
      Kp := 2
    main_arm.Drive(Kp*error*numBasePeriods/8192)
    waitms(delta_t)
    error := mainarm_pos - enc_pos
  main_arm.Stop()

