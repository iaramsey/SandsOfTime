{Object_Title_and_Purpose}


CON
  _clkfreq = 300_000_000                                                  'Standard clock frequency = 160 MHz

  {Absolute Encoder Constants}
  CS0 = 1    ' Start of encoder chip select pin range
  CSf = 12    ' End of encoder chip select pin range
  NumEnc = CSf - CS0 + 1
  CLK = 0
  DATA = 13
  AbsEncTolerance = 3 ' In encoder counts
  IndSensor = 36
  ArmEncTopPin = 33
  ArmEncBotPin = 32
  QuadEncTolerance = 50
  {Quadrature Encoder Constants}
  ExtendEncBotPin = 34
  ExtendEncTopPin = 35

  {Limit Switch Constants}
  LSExtend = 38
  LSRetract = 37

  numClockPulses = 10
  numBasePeriods = 1000

  ExtensionSpeed = 400



VAR
  long max_extend_pos
  long extend_pos
  byte extend_calibrated
  long Stack2[100], Stack3[100], Stack4[100], Stack5[100]
  word EncCurPos[NumEnc]
  word EncSetPoint[NumEnc]
  byte homed
  long mainarm_pos


obj

  arm_extend : "DRV8801"  | DIR=40, PWM=39, BRAKE=42, SLEEP=41, FAULT=-1, CS=-1, MinDuty=0 ' Currently CS not on the board
  arm_spin : "DRV8801"    | DIR=44, PWM=43, BRAKE=46, SLEEP=45, FAULT=-1, CS=-1, MinDuty=800
  main_arm : "BTS7960"    | RPWM=31, LPWM=30, R_EN=29, L_EN=28, R_IS=27, L_IS=26, MinDuty=400 ' Currently enables are just to 5V
dat
' where arm needs to be to reach a certain hourglass (starting at index 0, hour 1)
hour_pos word 7416, 6688, 6360, 5496, 4784, 4136, 3456, 2768, 2056, 1408, 776, 0

{pub newtest()
  arm_extend.InitPins(numClockPulses, numBasePeriods) ' Need to do this in the cog
  arm_extend.DriveBackward(1000)
  waitms(5000)
  arm_extend.Stop()
  arm_extend.DriveForward(1000)
  waitms(5000)
  arm_extend.Stop()}

pub FullTest()
  arm_extend.InitPins(numClockPulses, numBasePeriods)
  main_arm.InitPins(numClockPulses, numBasePeriods)
  arm_spin.InitPins(numClockPulses, numBasePeriods)
  cogspin(4, ReadAbsEncoders(), @Stack4)
  cogspin(5, RGB_LED_Demo2(), @Stack5)

  {arm_extend.DriveBackward(1000)
  waitms(5000)
  arm_extend.Stop()}

  main_arm.DriveBackward(400)
  waitms(1000)
  main_arm.Stop()
  homed:=0
  cogspin(3, ReadMainArmEncoder(), @Stack3)
  repeat until homed==1
  waitms(2000)

  arm_extend.DriveForward(1000)
  waitms(2850)
  arm_extend.Stop()

  arm_spin.DriveForward(1000)
  waitms(2000)
  arm_spin.Stop()

  arm_extend.DriveBackward(1000)
  waitms(2500)
  arm_extend.Stop()

{{Rotates the main arm to absolute encoder position given by enc_pos}}
pub SetMainArmPos(enc_pos) | error ' TODO: optimize to understand it is a circle
  error := enc_pos - mainarm_pos
  main_arm.DriveBackward(400)
  repeat while abs error > QuadEncTolerance
    error := enc_pos - mainarm_pos
  main_arm.Stop()

{{Home the main arm and then constantly read the encoder}}
pub ReadMainArmEncoder()
  dirlow(IndSensor) ' Inverted logic
  main_arm.InitPins(numClockPulses, numBasePeriods)
  ' Home main arm
  if pinr(IndSensor) <> 0
    ' Drive until it hits the induction sensor
    main_arm.DriveBackward(400)
    repeat until pinr(IndSensor) == 0
    main_arm.Stop()
    homed:=1
  mainarm_pos:=0
  ' Start the quadrature encoder
  pinstart(ArmEncBotPin, p_quadrature + %0000<<28 + %0001<<24, 0, 0)
  ' could find max counts
  repeat
    if pinr(IndSensor)==0
      mainarm_pos:=0
      dirlow(ArmEncBotPin) ' Should reset the count on the pin
      dirhigh(ArmEncBotPin)
    mainarm_pos := rdpin(ArmEncBotPin)
    debug(`mainArm '`(mainarm_pos)' 10)
    waitms(50)

{{Calculates and returns the direction (positive or negative) and distance from the current absolute encoder count to the target}}
pub CalculateAbsError(current, target) : error
  error := target - current
  ' Theoretically handles wraparound
  if abs error > 512
    if error < 0
      error:=error+1024
    else
      error:=error-1024
pub ReadAbsEncoders() | i, value
  'pst.start(9600)
  dirhigh(CLK)
  pinh(CLK)
  dirlow(DATA)
  repeat i from CS0 to CSf
    dirhigh(i)
    pinh(i)
  ' dirh(CSF..CS0) ' TODO
  'pinh(CSf..CS0)
  repeat
    repeat i from CS0 to CSf
      pinl(i) ' Chip Select
      waitus(1) ' Propeller 2 fast 2 furious
      pinl(CLK)
      waitus(1)
      value:=0
      repeat 16   ' Read 16 bits (top 10 are position)
        pinh(CLK)
        waitus(1)
        value := (value << 1) | pinr(DATA)
        pinl(CLK)
        waitus(1)
      EncCurPos[i-CS0] := value >> 6
      {pst.dec(i-CS0+1)
      pst.str(string(": "))
      pst.dec(value >> 6)
      pst.NewLine()}
      pinh(CLK)
      waitus(1)
      pinh(i)
      waitus(1)
    'waitms(200)
    'pst.ClearHome()
  {{Rotate the hourglass indicated by hr_i (0-11 where 0=1 and 11=12) to an absolute encoder position given by enc_pos}}
pub RotateHourglass(hr_i, enc_pos) | error
  EncSetPoint[hr_i] := enc_pos
  error := CalculateAbsError(EncCurPos[hr_i], enc_pos)
  repeat while abs error > AbsEncTolerance
    arm_spin.Drive(error*numBasePeriods/1024)
    error := CalculateAbsError(EncCurPos[hr_i], enc_pos)
  arm_spin.Stop()

pub TestExtension()
  extend_calibrated:=0
  arm_extend.InitPins(numClockPulses, numBasePeriods) ' Need to do this in the cog
  arm_extend.DriveBackward(1000)
  waitms(2500)
  arm_extend.Stop()

  arm_extend.DriveForward(1000)
  waitms(2500)
  arm_extend.Stop()
  'Retract()
  repeat
  cogspin(4, ReadExtensionEncoder(), @Stack4)   ' Process reading quadrature encoder
  debug("Waiting...")
  repeat until extend_calibrated==1
  debug("Done.")


{{Set up limit switches as inputs and determine maximum encoder counts then constantly updates the quadrature encoder count}}
pub ReadExtensionEncoder()
  dirlow(LSExtend)
  dirlow(LSRetract)
  arm_extend.InitPins(numClockPulses, numBasePeriods) ' Need to do this in the cog
  ' Drive Backward and hit limit switch --> 0 position
  Retract()

  'Start quadrature encoder smartpin reader watching provided Pin (Apin=%0000) and +1 pin up, (so Bpin=%0001)
  pinstart(ExtendEncBotPin, p_quadrature + %0000<<28 + %0001<<24, 0, 0)

  ' Drive Forward and hit 2nd limit switch --> Max position
  Extend()
  max_extend_pos := rdpin(ExtendEncBotPin)

  ' Return to 0
  Retract()
  extend_calibrated:=1 'let main cog know to start up
  repeat
    ' TODO: zero on limit switch
    if pinr(LSRetract)==1
      extend_pos:=0
    extend_pos := rdpin(ExtendEncBotPin)
    debug(`extender '`(extend_pos)' 10)
    waitms(50)

{{Extends arm until it hits the limit switch}}
pub Extend()
  ' If the limit switch is already pressed, do nothing
  if pinr(LSExtend) <> 1
    ' Else drive the arm forward until LSExtend reads 1 or stall is detected
    arm_extend.DriveForward(ExtensionSpeed)
    repeat until pinr(LSExtend) == 1 '|| arm_extend.ReadCurrent() > StallThreshold
  ' Stop
  arm_extend.Stop()


{{Retracts arm until it hits the limit switch}}
pub Retract()
  ' If the limit switch is already pressed, do nothing
  if pinr(LSRetract) <> 1
    ' Else drive the arm backward until LSRetract reads 1
    arm_extend.DriveBackward(ExtensionSpeed)
    repeat until pinr(LSRetract) == 1 '|| arm_extend.ReadCurrent() > StallThreshold
  ' Stop
  arm_extend.Stop()

{{Extends the arm to a quadrature encoder count given by enc_pos}}
pub ExtendArm(enc_pos) | error
  error := enc_pos - extend_pos
  repeat while abs error > QuadEncTolerance
    arm_extend.Drive(error*numBasePeriods/max_extend_pos) ' TODO: Find good Kp
    error := enc_pos - extend_pos
  arm_extend.Stop()

{Pin Helper Methods}
pri dirhigh(pin) ' TODO: Make these do pin ranges
  if pin > 31
    dirb.[pin-32]~~
  else
    dira.[pin]~~

pri dirlow(pin)
  if pin > 31
    dirb.[pin-32]~
  else
    dira.[pin]~

{ LED Stuff}
con
  maxaddress = 1_196             'For an 8x8 array, LEDs are addressed from 0-63 (increase this value if using arrays or strips with more LEDs)

 'Predefined colors                               green      red      blue
  off            = 0                            '%00000000_00000000_00000000
  red            = 255<<8                       '%00000000_11111111_00000000
  green          = 255<<16                      '%11111111_00000000_00000000
  blue           = 255                          '%00000000_00000000_11111111
  white          = 255<<16+255<<8+255           '%11111111_11111111_11111111
  cyan           = 255<<16+255                  '%11111111_00000000_11111111
  magenta        = 255<<8+255                   '%00000000_11111111_11111111
  yellow         = 255<<16+255<<8               '%11111111_11111111_00000000
  chartreuse     = 255<<16+127<<8               '%11111111_01111111_00000000
  orange         = 165<<16+255<<8               '%10100101_11111111_11010100
  aquamarine     = 255<<16+127<<8+212           '%11111111_01111111_11010100
  pink           = 192<<16+255<<8+203           '%11000000_11111111_11001011
  turquoise      = 224<<16+64<<8+192            '%11100000_01000000_11000000
  realwhite      = 255<<16+200<<8+255           '%11111111_11001000_11111111
  indigo         = 75<<8+130                    '%00000000_01001011_10000010
  violet         = 130<<16+238<<8+238           '%10000010_11101110_11101110
                                                                                                            bTT5
var
  long lights[1_196]     'Create an array of 1,196 longs to hold the color values of each LED in 92*13=1196

pub RGB_LED_Demo2() | i,j,x

  pr0:=@lights                 'Store Hub RAM address of start of "lights" array as pr0 (which PASM can read)
  pr1:=48                      'Specify first output pin as pr1 (which PASM can read), in this case, Pin 47 will be the first output and




  {
  repeat i from 0 to 12
    spin_bounce(i,randomcolor(),30)
  }

  repeat
    spin_all(randomcolor(),30)





  {
  repeat
    longfill(@lights,int(red,30),1_196)
    Update()
    waitms(500)
    longfill(@lights,blue,1_196)
    Update()
    waitms(500)
    longfill(@lights,green,1_196)
    Update()
    waitms(500)
    section(0,0,71,cyan)
    section(1,0,71,indigo)
    waitms(2000)


  repeat
    AllOff()                      'You can turn off all of the LEDs at once
    waitms(1000)

    led(0,0,red)                    'ROYGBIV Rainbow demo
    led(0,1,orange)                 'You can set a specific LED address to a predefined color
    led(0,2,yellow)
    led(0,3,green)
    led(0,4,blue)
    led(0,5,indigo)
    led(0,6,violet)
    led(0,7,white)
    'waitms(1000)

    led(12,0,red)                    'ROYGBIV Rainbow demo
    led(12,1,orange)                 'You can set a specific LED address to a predefined color
    led(12,2,yellow)
    led(12,3,green)
    led(12,4,blue)
    led(12,5,indigo)
    led(12,6,violet)
    led(12,7,white)
    'waitms(1000)

    Update()
    waitms(7000)

    clear()                       'If you prefer, you can use "clear" instead of AllOff to turn off all lights
  }

  {                               'You can also set the 8-bit RGB color values manually
    led(8,255<<16)                'Set color to green=255 (red=blue=0)
    led(9,255<<8)                 'Set color to red=255 (green=blue=0)
    led(10,255)                   'Set color to blue=255 (green=red=0)
    led(11,32<<16+32<<8+32)       'Set color to green=32 red=32 blue=32 (white)
    led(12,$20_20_20)             'Or use hexadecimal* green=$20 red=$20 blue=$20 (white)
    led(13,%00100000_00100000_00100000) 'Or 24-bit binary* where %11111111=255(white)
    led(14,2105376)               'Or one big decimal number*
    led(15,white)                 'Or just a predefined color constant
    waitms(1000)                  '*These are cruel and unusual forms of punishment for anyone reading your code
    AllOff()

           '   G   R   B           You can also set each color component individually using the ledgrb method
    ledgrb(16,64,64,64)           'Set color to green=64  red=64  blue=64 (white)
    ledgrb(17,64,0,0)             'Set color to green=0   red=64  blue=0  (green)
    ledgrb(18,0,64,0)             'Set color to green=64  red=0   blue=0  (red)
    ledgrb(19,0,0,64)             'Set color to green=0   red=0   blue=64 (blue)
    ledgrb(20,64,64,0)            'Set color to green=64  red=64  blue=0  (magenta)
    ledgrb(21,64,0,64)            'Set color to green=64  red=0   blue=64 (cyan)
    ledgrb(22,127,255,212)        'Set color to green=127 red=255 blue=212
    random(23)                    'You can also set a color to be random
    waitms(1000)
    clear()

    section(24,39,int(red,64))    'You can set sections of the strip's LEDs to one color at once
    waitms(1000)

    section(40,maxAddress,(int(blue,64)))  'You can set sections of the strip's LEDs to one color at once
    waitms(1000)

    repeat i from 0 to 63         'You can adjust the intensity of any color to a value 0-255
      ledint(i,cyan,i)
    waitms(1000)
    clear()

    allset(int(red,64))           'You can set all of the strip's LEDs to one color at once
    waitms(500)                   ' and adjust the intensity/brightness 0-255
    allset(int(green,64))
    waitms(500)
    allset(int(blue,64))
    waitms(500)
    clear()

    repeat 3
      repeat i from maxAddress to 0
        led(i,int(white,32))
        waitms(20)
      repeat i from 0 to maxAddress
        led(i,int(red,128))
        waitms(20)
      repeat i from maxAddress to 0
        led(i,int(green,128))
        waitms(20)
      repeat i from 0 to maxAddress
        led(i,int(blue,128))
        waitms(20)

    repeat i from 0 to maxaddress
      ledint(i,cyan,64)
      waitms(50)

    repeat                                           'Repeat this last demo forever
      x:=int(randomcolor(),128)                      'Get a random color and set its intensity to 50%
      repeat i from 0 to maxAddress/2
        led((maxAddress/2+1)+i,x)
        led(maxAddress/2-i,x)
        waitms(20)
      waitms(100)
      repeat i from 0 to maxAddress/2
        led(i,off)
        led(maxAddress-i,off)
        waitms(20)
          }

pub Update() 'General-purpose Registers Used: pr0=address of "lights" variable, pr1=pin (these are passed to PASM from the Spin2 code)
  pinl((pr1+12)..pr1)            'Send Low reset signal to WS2812B LEDs
  waitus(300)                    'Reset signal width is 300us

          org                    'Jump into inline Propeller 2 Assembly Code (running at ~6.67ns per line)
          mov counter,#0         'Reset counter to 0
          mov outputpin,pr1      'Start with 1st output pin
          mov index,pr0          'Copy Hub RAM address of start of "lights" array to index variable
          mov EndAddr,pr0        'Copy Hub RAM address of start of "lights" array to EndAddr variable
Loop0     add EndAddr,#368       'Add 92 to EndAddr variable to get the last/end address of this section of the "lights" array

Loop1     rdlong ledcolor,index  'Load new long of color data, output 24 bits to LED matrix
          mov bit,#23            'Reset bit index pointer to 23
Loop2     call #OutputBit        'Read and output bits 23 through 1
          djnz bit, #Loop2       'Decrement bit index by 1, and if it is not zero, jump back up to "Loop2" line
          call #OutputBit        'Read and output the last bit (bit zero) as well

          add index,#4           'Move on to next long of data (4 bytes) representing the next LED in the "lights" array
          cmp index,EndAddr  wz  'Check to see if index has reached end address, write Z flag if it has
    if_nz jmp #Loop1             'If index is not zero, jump back up to "Loop1" line to grab another long of LED data

          add counter,#1         'Add one to the counter
          add outputpin,#1       'Add one to the output pin (stepping up from Pins 47-59)
          cmp counter,#12  wz    'Check to see if counter has reached 12, write Z flag if it has
    if_nz jmp #Loop0

OutputBit testb ledcolor,bit wz  'Test bit from color data long, set Z flag to bit's state
          drvh outputpin               'Drive output data pin High (start with pin on)
    'If bit is High, send a One pulse signal (800ns High, 800ns Low)
    if_z  waitx #238             'Wait for 800ns  (800ns/3.33ns=240, 240-2=238) (See WS2812B datasheet version 5)
    if_z  drvl outputpin              'Drive output data pin Low
    if_z  waitx #238             'Wait for 800ns  (800ns/3.33ns=240, 240-2=238)
    'If bit is Low, send a Zero pulse signal (200ns High, 800ns Low)
    if_nz waitx #88              'Wait for 300ns  (300ns/3.33ns=90, 90-2=88)
    if_nz drvl outputpin               'Drive output data pin Low
    if_nz waitx #238             'Wait for 800ns  (800ns/3.33ns=240, 240-2=238) (See WS2812B datasheet)
          ret                    'Return from OutputBit subroutine

counter   long 0                 'Use to store the counter value that counts which section of lights are being worked with
index     long 0                 'Use as an index to specify LED number in the "lights" array matrix 0-63
outputpin long 0                 'Keeps track of the output pin
bit       long 0                 'Keeps track of which bit in the color data is being read and transmitted
ledcolor  long 0                 'Stores an LED's color data from "lights" array in Hub RAM
StartAddr long 0                 'Stores the starting Hub RAM address of "lights" array (for a set of 93 lights)
EndAddr   long 0                 'Stores the final Hub RAM address of "lights" array (for a set of 93 lights)
          end                    'End in-line assembly program


pub led(ring,LEDaddress,color)                            ''Changes the color of an LED at a specific address
  lights[(ring*92)+LEDaddress]:=color
  'Update()

{pub led(LEDaddress,color)                            ''Changes the color of an LED at a specific address
  lights[LEDaddress]:=color
  Update()
}
pub ledgrb(ring,LEDaddress,_green,_red,_blue)             ''Changes GRB values of an LED at a specific address
  lights[(ring*92)+LEDaddress]:=_green<<16+_red<<8+_blue
  Update()

pub ledrgb(ring,LEDaddress,_red,_green,_blue)             ''Changes RGB values of an LED at a specific address
  lights[(ring*92)+LEDaddress]:=_green<<16+_red<<8+_blue
  Update()

pub ledint(ring,LEDaddress,color,intense)                 ''Changes the color of an LED at a specific address
  lights[(ring*92)+LEDaddress]:=((((color>>16)*intense)/255)<<16) +((((color>>8 & $FF)*intense)/255)<<8)+(((color & $FF)*intense)/255)
  Update()

pub intensity(color,intense) : newvalue              ''Changes the intensity (0-255) of a color
  newvalue:=((((color>>16)*intense)/255)<<16) +((((color>>8 & $FF)*intense)/255)<<8)+(((color & $FF)*intense)/255)

pub int(color,intense) : newvalue                    ''Changes the intensity (0-255) of a color
  newvalue:=((((color>>16)*intense)/255)<<16) +((((color>>8 & $FF)*intense)/255)<<8)+(((color & $FF)*intense)/255)

pub allset(setcolor) | i                             ''Changes the colors of all LEDs to the same color
  longfill(@lights,setcolor,maxAddress+1)
  Update()

pub alloff() | i                                     ''Turns all of the LEDs off
  longfill(@lights,0,maxAddress+1)
  Update()
  waitms(100)             'Can't send the next update too soon

pub clear() | i                                      ''Turns all of the LEDs off
  longfill(@lights,0,maxAddress+1)
  Update()
  waitms(100)             'Can't send the next update too soon

pub section(ring,AddressStart,AddressEnd,setcolor)        ''Changes colors in a section of LEDs to same color
  longfill(@lights[ring*92+AddressStart],setcolor,AddressEnd-AddressStart+1)'(@lights[AddressEnd]-@lights[AddressStart])/4)
  Update()

{pub GetColor(address) : color                        ''Returns 24-bit RGB value from specified LED's address
  color:=lights[address]
}
pub random(address) | rand,_red,_green,_blue,timer   ''Sets LED at specified address to a random color
  rand:=getrnd()
  _red:=rand>>24
  rand:=getrnd()
  _green:=rand>>24
  rand:=getrnd()
  _blue:=rand>>24
  lights[address]:=_green<<16+_red<<8+_blue
  Update()

pub randomcolor() : randcolor | rand,_red,_green,_blue,timer   ''Generates and returns a random color value
  rand:=getrnd()
  _red:=rand>>24
  rand:=getrnd()
  _green:=rand>>24
  rand:=getrnd()
  _blue:=rand>>24
  randcolor:=_green<<16+_red<<8+_blue

pub spin_bounce(ring,color,power) | i,j,k

  repeat i from 0 to 91
    repeat k from 0 to i
      led(ring,i,int(color,power))
    update()
    waitus(5)

  repeat j from 0 to 91
    led(ring,j,0)
    update()
    waitus(5)

  repeat k from 0 to 2
    section(ring,0,91,int(color,power))
    update()
    waitms(250)
    section(ring,0,91,0)
    update()
    waitms(250)
  section(ring,0,91,int(color,power))

pub spin_all(color,power) | ring,i,j,k


  repeat j from 0 to 91
    repeat ring from 0 to 11
      repeat k from 0 to j
        led(ring,k,int(color,power))
    update()

  repeat ring from 0 to 11
     repeat j from 0 to 91
       led(ring,j,0)
    update()
    waitus(5)
    update()


pub spin_down(ring,color)| i

section(ring,0,91,int(color,125))
repeat i from 0 to 91
  led(ring,i,0)
  waitus(3260869)