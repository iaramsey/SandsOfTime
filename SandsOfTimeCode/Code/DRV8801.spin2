{DRV8801 Motor Driver Library}

con
  _clkfreq = 300_000_000
  DIR = 31     ' Logic input for controlling motor direction.
  PWM = 30     ' Logic input for enabling the driver outputs/controlling motor speed. A PWM signal can be applied to this pin.
  B = 2      ' Logic input for controlling whether the driver brakes low or coasts when PWM pin is low. A logic high results in braking (slow-decay through ground).
  SLP = 3      ' Logic input that puts the DRV8801 into a low-power sleep mode when low.
  FAULT = 4   ' Logic output that drives low when a fault occurs. The carrier board pulls this pin up to VDD.
  CS = 5      ' Analog voltage output proportional to motor current (500 mV per A). Note: this pin will output 0 V whenever the driver is in slow-decay mode (i.e., when BRAKE/MODE1 is HIGH).


  ' *** DELETE THESE AFTER TESTING
  LS1 = 0
  LS2 = 1
  ExtendEncBotPin = 2
var
  long clockPulses, basePeriods

  ' *** DELETE THESE AFTER TESTING
  long max_extension_count, extend_enc_count

obj 
  pst: "pst_driver"
pub Main()
  dira.[LS1]~
  dira.[LS2]~

   ' Drive Backwards and hit limit switch --> 0 position
  repeat until ina.[LS1] == 1 ' may need to be 1
    DriveBackward(250)
  Stop()
  'Start quadrature encoder smartpin reader watching provided Pin (Apin=%0000) and +1 pin up, (so Bpin=%0001)
  pinstart(ExtendEncBotPin, p_quadrature + %0000<<28 + %0001<<24, 0, 0) ' TODO: Maybe more dynamic pin selection
  
  ' Drive Forwards and hit 2nd limit switch --> Max position
  repeat until ina.[LS2] == 1
    extend_enc_count := rdpin(ExtendEncBotPin)
    pst.dec(extend_enc_count)
    pst.NewLine()
    DriveForward(250)
  Stop()

  max_extension_count := rdpin(ExtendEncBotPin)
  ' pinstart(SpinEncBotPin, p_quadrature + %0000<<28 + %0001<<24, 0, 0) 
  repeat
    extend_enc_count := rdpin(ExtendEncBotPin)
    pst.dec(extend_enc_count)
    pst.NewLine()
    ' spin_enc_count := rdpin(SpinEncBotPin)
    ' TODO: Deal with limit switches


{{
  Initialize all pins with correct direction and start PWM Smart Pin
    DIR default 0
    PWM default 0 duty cycle
    BRAKE default 0 (off)
    SLEEP default 1 (off)
}}
pub InitPins(numClockPulses, numBasePeriods) | x
  dira.[DIR]~~
  outa.[DIR]~
  x.word[0] := numClockPulses     'Set base period's # of clock pulses 10*3.33ns=33ns
  x.word[1] := numBasePeriods   'Set PMW frame period to be made up of 1000 base periods
  clockPulses := numClockPulses
  basePeriods := numBasePeriods
  pinstart(PWM, p_oe+p_pwm_triangle, x, 0) 'Start PWM smartpin

  ' May want to provide optional NC
  dira.[B]~~
  outa.[B]~
  dira.[SLP]~~
  outa.[SLP]~~
  dira.[FAULT]~
  dira.[CS]~ ' This would need to be a smart pin

{{Drive motor forward with speed 0-numBasePeriods}}
pub Drive(speed)
  outa.[DIR] := (speed >> 31 & 1) ' Direction determined by sign of number (2s complement)
  wypin(PWM, 0#>abs speed<#basePeriods)

pub Drive2(speed, direction) ' any value other than 0 drives backwards
  outa.[DIR] := direction
  wypin(PWM, 0#>speed<#basePeriods)

pub DriveForward(speed)
  outa.[DIR]~
  wypin(PWM, 0#>speed<#basePeriods) ' TODO: Maybe incorporate a minimum duty cycle

pub DriveBackward(speed)
  outa.[DIR]~~
  wypin(PWM, 0#>speed<#basePeriods)

pub Stop()
  ' Turn off PWM
  wypin(PWM, 0)

pub Brake()
  outa.[B]~~

pub Unbrake() ' Weird name
  outa.[B]~

pub Sleep()
  outa.[SLP]~

pub Wake()
  outa.[SLP]~~